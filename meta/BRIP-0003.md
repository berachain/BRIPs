---
mip: 0003
title: Stable Block Time
author: aBear, fridrik01
status: Accepted
created: 2025-06-16
type: Core
---

## Summary

Stable Block Time (SBT) introduces a mechanism for ensuring consistent block intervals in CometBFT-based blockchains. This enables the Berachain network to target a fixed average block production interval (e.g., one block every 2 seconds), thus stabilizing BGT inflation in the absence of network partition issues.

## Motivation

Currently, Berachain validators control block production timing via `timeout_commit` parameter in `config.toml` (default value: `500ms`). Once a block is finalized, the block proposer waits `500ms` before building the next block, regardless of whether the network is congested or not. This fixed delay approach assumes that most validators (~â…” of the voting power) agree on the same configuration. Moreover, it lacks dynamic adaptability to network stalls or multi-round consensus, often leading to longer and inconsistent block times.

SBT proposes an algorithmic delay model that dynamically adjusts based on the difference between the actual and expected block times, using a well-defined initial time and height checkpoint. The expected time for the next block is calculated as:

```go
expectedBlockTime := initialTime + (TargetBlockTime * (currentBlockHeight-initialHeight))
```

where

- `TargetBlockTime` is the desired interval between blocks
- `initialTime` and `initialHeight` are the time and height of the well-defined checkpoint
- `currentBlockHeight` is the height of the current block

This formula ensures that CometBFT adds delays when blocks are produced early, proceeds immediately when blocks are on time, and allows rapid catch-up when blocks are late - all to maintain the long-term average block time at the target interval.

Finally, SBT proposes a minor modification to the logic above, to account for chain halts. While Berachain chain is meant to produce blocks continuously, prolonged halts due to downtime, upgrades or bugs are always possible. If they were to happen, the algorithm above would force blocks to be produced as fast as possible in order to catch up with the downtime.

To avoid unintended block rushes, SBT proposes a reset policy for the internal checkpoint `(initialTime, initialHeight)`: if the time between blocks exceeds a `MaxDelayBetweenBlocks`, `initialTime` is reset to the current block as if the upgrade happened just now. This ensures stable timing resumes from the current block, avoiding rushes.

## Specification

### SBTEnableHeight consensus parameter

Similar to `vote_extensions_enable_height`, to ensure consistency across the network, a new consensus parameter is introduced:

```go
type Feature struct {
  SBTEnableHeight int64 `json:"sbt_enable_height"`
}
```

By default, SBT is disabled:

```go
Feature{
  SBTEnableHeight: 0,
}
```

When `SBTEnableHeight > 0`, BeaconKit must activate SBT logic starting at the specified height.

When a BeaconKit node restarts after the chain has passed `SBTEnableHeight`, it must ensure the consensus parameter is correctly set to the original enable height. If the node fails to set this parameter, CometBFT will reject the handshake during replay with an error: "SBT cannot be disabled once enabled". This issue is addressed in [PR #2870](https://github.com/berachain/beacon-kit/pull/2870).

### NextBlockDelay function

```go
func (app *Application) FinalizeBlock(_ context.Context, req *types.FinalizeBlockRequest) (*types.FinalizeBlockResponse, error) {
  // ...
  return &cmtabci.FinalizeBlockResponse{
    // ...
    NextBlockDelay: app.nextBlockDelay(req),
  }, nil
}

func (app *Application) nextBlockDelay(req *cmtabci.FinalizeBlockRequest) time.Duration {
  // timeoutCommit is read from a config file but defaults to 500 milliseconds
  const timeoutCommit = 500 * time.Millisecond

  sbtEnableHeight := app.consensusParams.Feature.SBTEnableHeight

  // SBT is not enabled => use the old block delay.
  if sbtEnableHeight <= 0 {
    return timeoutCommit
  }

  // Case 1: current height < SBTEnableHeight => wait for the upgrade.
  if req.Height < sbtEnableHeight {
    return timeoutCommit
  }

  // Case 2: current height == SBTEnableHeight => initialize the block delay.
  if req.Height == sbtEnableHeight {
    s.blockDelay = &BlockDelay{
      InitialTime:       req.Time,
      InitialHeight:     req.Height,
      PreviousBlockTime: req.Time,
    }
    return timeoutCommit
  }

  // Case 3: current height > SBTEnableHeight => compute next block delay
  if s.blockDelay != nil {
    return s.blockDelay.Next(req.Time, req.Height)
  }

  panic(fmt.Sprintf(
      "SBT not initialized at height %d (past enable height %d). State sync is not supported",
      req.Height,
      sbtEnableHeight,
  ))
}

func (d *BlockDelay) Next(curBlockTime time.Time, curBlockHeight int64) time.Duration {
  // We can't use 0 delay as that would make CometBFT read the timeout_commit from config file
  const noDelay = 1 * time.Microsecond

  // Reset the initial time and height if the time between blocks is greater
  // than MaxDelayBetweenBlocks. This makes the current time and height the
  // initial one as if the upgrade happened just now.
  if curBlockTime.Sub(d.PreviousBlockTime) > MaxDelayBetweenBlocks {
    d.InitialTime = curBlockTime
    d.InitialHeight = curBlockHeight
    d.PreviousBlockTime = curBlockTime
    return TargetBlockTime
  }

  d.PreviousBlockTime = curBlockTime

  expectedTime := d.InitialTime.Add(TargetBlockTime * time.Duration(curBlockHeight - d.InitialHeight))
  if curBlockTime.Before(expectedTime) {
    return expectedTime.Sub(curBlockTime)
  }
  return noDelay
}
```

To prevent rapid block generation after a prolonged halt (e.g., due to downtime or upgrades), the internal checkpoint is reset after `MaxDelayBetweenBlocks` - the maximum delay between two consecutive blocks. `MaxDelayBetweenBlocks` is set to `5 minutes`, which balances distinguishing real halts from network congestion while avoiding excessive catch-up.

To make this work, BeaconKit keeps track of `PreviousBlockTime`. BeaconKit must persist this, along with `initialTime` and `initialHeight`, for every block (on Commit) to ensure crash recovery.

### State Sync Support

Currently, SBT does not support [state sync](https://docs.cometbft.com/v1.0/explanation/core/state-sync). If a node syncs from a height greater than SBTEnableHeight, BeaconKit lacks access to the latest initialTime. In the first version of implementation, such scenarios must panic.

Future versions may introduce support for persisting and recovering SBT state from snapshots.

## Rationale

SBT leverages the [Predictable Block Times](https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-115-predictable-block-times.md) feature from CometBFT.

## Backward Compatibility

A hard fork is required to enable these changes. This change does not affect execution clients, so it is fully backward-compatible with existing wallets and applications.

Note that the fork activating SBT will be slot based rather than timestamp based. SBT leverages a CometBFT Predictable Block Times and requires a consensus parameter update which is carried out based on slot.

## Copyright

All copyrights and related rights in this work are waived under CCO 1.0 Universal.
