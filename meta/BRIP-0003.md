---
mip: 0003
title: Stable Block Time
author: aBear
status: Draft
created: 2025-06-16
type: Core
---

## Summary

Stable Block Time (SBT) introduces a mechanism for ensuring consistent block intervals in CometBFT-based blockchains. This enables Berachain network to target a fixed block production interval (e.g., one block every 2 seconds), thus stabilizing BGT inflation in absence of network partition issues.

## Motivation

Currently Berachain validators control block production timing via `timeout_commit` parameter in `config.toml` (default value: `500 ms`). Once a block is finalized, the block proposer waits `500 ms` before building the next block, whether the network is congested or not. This fixed delay approach assumes that most validators (~â…” of the voting power) agree on the same configuration. Moreover, it lacks dynamic adaptability to network stalls or multi-round consensus, often leading to inconsistent block times.

SBT proposes an algorithmic delay model that dynamically adjusts based on the difference between the actual and expected block times, using a well-defined initial time and height checkpoint. The idea is to calculate the expected time for the next block as follows:

```go
expectedBlockTime := initialTime + (TargetBlockTime * (currentBlockHeight-initialHeight))
```

where `TargetBlockTime` is the desired interval between blocks, and `(currentBlockTime, currentBlockHeight)` are the time and height of the current block.

What the formula above ensures is that:

- If the current block is early, CometBFT will add a delay, calculated so that the long-range average block time matches `TargetBlockTime`.
- If the current block is at time, there will be no delay and the network will immediately proceed to build and finalize next block.
- If the current block is late, `TargetBlockTime` cannot be immediately guaranteed. Still block production will proceed as fast as possible and likely next blocks will be produced rapidily too until long-range average block time catch up with `TargetBlockTime`.

Finally SBT proposes a minor modification to the logic above, to account for chain halts. While Berachain chain is meant to produce blocks no stop, prolonged halts due to downtime, upgrades or bugs are always possible. If they ever to happen, the algorithm above would force blocks to be produced as fast as possible in order to catch up with the downtime.

To avoid unintended block rushes, SBT proposes a reset policy for the internal checkpoint `(initialTime, initialHeight)`: if the time between blocks exceeds a `MaxDelayBetweenBlocks`, `initialTime` is reset to the current block as if the upgrade happened just now. This ensures stable timing resumes from the current block, avoiding rushes.

## Specification

### SBTEnableHeight consensus parameter

Similarly to `vote_extensions_enable_height`, to ensure consistency across the network, a new consensus parameter is introduced:

```go
type Feature struct {
  SBTEnableHeight int64 `json:"sbt_enable_height"`
}
```

By default, SBT is disabled:

```go
Feature{
  SBTEnableHeight: 0,
}
```

When `SBTEnableHeight > 0`, BeaconKit must activate SBT logic starting at the specified height.

### NextBlockDelay function

```go
func (app *Application) FinalizeBlock(_ context.Context, req *types.FinalizeBlockRequest) (*types.FinalizeBlockResponse, error) {
 // ...
 return &cmtabci.FinalizeBlockResponse{
  // ...
  NextBlockDelay:        app.nextBlockDelay(req),
 }, nil
}
```

- Case 1: `height < SBTEnableHeight`
  Return the old value of `timeout_commit`.
- Case 2: `height == SBTEnableHeight`
  Record block time (initialTime) and return the old value of `timeout_commit`.
- Case 3: `height > SBTEnableHeight`
  Use the previously recorded block time (initialTime) to calculate the expected block time and delay. Return the difference as a delay if the block comes before the expected time. Otherwise, return 0 (no delay).

Here is the pseudo code for `nextBlockDelay` function:

```go
func (app *Application) nextBlockDelay(req *cmtabci.FinalizeBlockRequest) time.Duration {
 // c0. SBT is not enabled => use the old block delay.
 if app.consensusParams.Feature.SBTEnableHeight <= 0 {
  return constBlockDelay
 }

 // c1. current height < SBTEnableHeight => wait for the upgrade.
 if req.Height < app.consensusParams.Feature.SBTEnableHeight {
  return constBlockDelay
 }

 // c2. current height == SBTEnableHeight => initialize the block delay.
 if req.Height == app.consensusParams.Feature.SBTEnableHeight {
  s.blockDelay = &BlockDelay{
   InitialTime:       req.Time,
   InitialHeight:     req.Height,
   PreviousBlockTime: req.Time,
  }
  return constBlockDelay
 }

 // c3. current height > SBTEnableHeight
 // c3.1
 //
 // The upgrade was successfully applied and the block delay is set.
 if s.blockDelay != nil {
  return s.blockDelay.Next(req.Time, req.Height)
 } else {
  // c3.2
  //
  // Looks like we've skipped SBTEnableHeight (probably restoring from the
  // snapshot) => panic.
  panic(fmt.Sprintf("nil block delay at height %d past SBTEnableHeight %d. This is only possible w/ statesync, which is not supported by SBT atm",
   req.Height, app.consensusParams.Feature.SBTEnableHeight))
 }
}
```

### Adapting NextBlockDelay if a chain halts for a prolonged period

The complete version of `blockDelay.Next` function looks like this:

```go
// Next returns the duration to wait before proposing the next block.
func (d *BlockDelay) Next(curBlockTime time.Time, curBlockHeight int64) time.Duration {
 // Until `timeout_commit` is removed from the CometBFT config,
 // `FinalizeBlockResponse.NextBlockDelay` can't be exactly 0. If it's set to
 // 0, then `timeout_commit` from the config will be used, which is not what
 // we want since we're trying to control the block time.
 const noDelay = 1 * time.Microsecond

 // Reset the initial time and height if the time between blocks is greater
 // than MaxDelayBetweenBlocks. This makes the current time and height the
 // initial one as if the upgrade happened just now.
 if curBlockTime.Sub(d.PreviousBlockTime) > MaxDelayBetweenBlocks {
  d.InitialTime = curBlockTime
  d.InitialHeight = curBlockHeight
  d.PreviousBlockTime = curBlockTime
  return TargetBlockTime
 }

 d.PreviousBlockTime = curBlockTime

 t := d.InitialTime.Add(TargetBlockTime * time.Duration(curBlockHeight-d.InitialHeight))
 if curBlockTime.Before(t) {
  return t.Sub(curBlockTime)
 }
 return noDelay
}
```

To prevent rapid block generation after a prolonged halt (e.g., due to downtime or upgrades), there is a reset of the internal checkpoint after `MaxDelayBetweenBlocks`, the maximum delay between two consecutive blocks. `MaxDelayBetweenBlocks` is set to `5 minutes`.

To make this work, BeaconKit keeps track of `PreviousBlockTime`. BeaconKit must persist this, along with initialTime & initialHeight, for every block (on Commit) to ensure crash recovery.

### Statesync support

Currently, SBT does not support [state sync](https://docs.cometbft.com/v1.0/explanation/core/state-sync). If a node syncs from a height greater than SBTEnableHeight, BeaconKit lacks access to the latest initialTime. In this version, such scenarios must panic:

Future versions may introduce support for persisting and recovering SBT state from the snapshot.

## Rationale

SBT leverages [Predictable Block Times](https://github.com/cometbft/cometbft/blob/main/docs/references/architecture/adr-115-predictable-block-times.md) feature from CometBFT.

## Backward Compatibility

A hard fork is required to enable these changes. This change does not affect the execution clients so it is fully backward-compatible with existing wallet and applications.

## Security Considerations

Any security risks or mitigations.

## Copyright

All copyrights and related rights in this work are waived under CCO 1.0 Universal.
