---
mip: 0004
title: Enshrined Proof of Liquidity Reward Distribution
author: rezbera, calbera
status: Draft
created: 2025-06-19
type: Core
requires: BRIP-0001
---

## Summary

This BRIP proposes enshrining the `distributeFor` smart contract function call into the execution layer, enabling automatic incentive fulfillment at the beginning of each block without relying on external transactions or bots. This change eliminates gas costs and timing dependencies for Proof of Liquidity reward distribution, enabling real-time reward processing and improved network economics. **A key requirement of this proposal is reducing the cutting board queue to real-time execution**, allowing validators to update their BGT rewards distribution strategy with complete chain state visibility for future reward optimization. **Distribution at the top of the next block is effectively equivalent to same-block distribution**, since no other on-chain actions can occur between the end of the current block and the enshrined distribution call.

## Motivation

Berachain's Proof of Liquidity consensus mechanism requires regular incentive fulfillment for validators based on their liquidity provision. In exchange for these incentives, validators direct BGT rewards to vaults through their cutting board configuration, configured in a smart contract. The `distributeFor` function performs this incentive fulfillment. Currently, this process relies on external actors calling the `distributeFor` function, which presents several limitations:

1. **Gas Dependency**: Distribution transactions compete with user transactions for block space and are subject to gas price fluctuations
2. **Timing Uncertainty**: No guarantee that reward distribution occurs promptly after each block
3. **Bot Infrastructure**: Requires maintaining external infrastructure to monitor and trigger distributions
4. **Economic Inefficiency**: Gas costs for distribution reduce overall network economic efficiency
5. **Cutting Board Queue Latency**: The current cutting board system introduces delays between strategy updates and their application, preventing validators from optimizing their BGT rewards distribution strategy with full chain state visibility

By enshrining `distributeFor` calls at the execution layer, we can guarantee that `distributeFor` performs incentive fulfillment deterministically for every block without external dependencies. **This proposal requires implementing real-time cutting board execution**, eliminating the existing queue delays and enabling validators to update their BGT rewards distribution strategy (cutting board) with complete chain state visibility, optimizing their strategy for future reward distribution. **Since distribution occurs at the very beginning of the next block before any other transactions**, this timing is functionally equivalent to same-block distribution. **This accelerates the Proof of Liquidity flywheel by enabling immediate optimization of BGT distribution**, allowing validators to respond instantly to market conditions and liquidity provision opportunities.

## Specification

### Execution Layer Integration

Berachain Labs will implement automatic `distributeFor` function calls at the beginning of each block processing in both Geth and Reth forked execution clients, before all regular transaction execution. This requires modifications to the block execution process in the forked clients.

### Contract Modifications

The `Distributor.sol` contract will require updates to support a new enshrined interface alongside the existing implementation:

#### New Enshrined Function Signature

A new simplified `distributeFor` function variant will be added that leverages previous proposer information available from forkchoice attributes:

```solidity
function distributeFor(bytes calldata pubkey) external onlySystemCall {
    _distributeFor(pubkey, uint64(block.timestamp));
}
```

#### Key Changes from Current Implementation

- **Removed proposer index and Merkle proofs**: The previous proposer pubkey will be provided directly from forkchoice attributes, eliminating the need for cryptographic proof verification
- **Removed nextTimestamp parameter**: The function now uses `block.timestamp` internally rather than accepting it as a parameter, simplifying the interface
- **Removed nonReentrant modifier**: The enshrined function does not include reentrancy protection as it's called by the system address in a controlled context
- **Previous proposer pubkey source**: The 48-byte BLS public key will be passed from the consensus layer via the `BerachainPayloadAttributes.ParentProposerPubkey` field
- **Simplified verification**: Trust the consensus layer data rather than requiring on-chain proof verification
- **Access control**: Only the system address (`0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE`) can call this simplified version

#### Contract Interface Updates

1. Add the new simplified function variant for enshrined calls using function overloading
2. Maintain the existing proof-based function for backward compatibility during transition period
3. Implement `onlySystemCall` modifier to restrict access to the system address (`0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE`)
4. Share common reward distribution logic through internal `_distributeFor()` function
5. **Event Emission**: The enshrined function emits the same events as the external function for consistency and observability
6. **Migration Path**: The external function should be disabled after hard fork activation to prevent frontrunning of the enshrined system call, and potentially removed entirely once the enshrined system proves stable

#### Error Handling and Non-Reverting Design

The enshrined `distributeFor` function is designed to never revert based on the smart contract implementation. However, if an unexpected revert occurs, the protocol will silently ignore the failure and continue block processing to ensure network stability. Such reverts indicate smart contract issues that need to be addressed.

#### Cutting Board Real-Time Execution

To enable real-time cutting board updates with complete chain state visibility, the `BeraChef` contract requires modifications to eliminate queue delays:

- **Queue Validation Updates**: Modify the queue validation logic to allow immediate activation by changing the validation from `startBlock > block.number + rewardAllocationBlockDelay` to `startBlock >= block.number`
- **Real-Time Strategy Updates**: This enables validators to update their cutting board configuration with complete chain state visibility, optimizing their strategy for future reward distribution. **Since distribution occurs at the top of the next block before any other transactions**, this effectively provides the same benefits as same-block distribution.

#### Cutting Board Operator Separation

To enhance security and operational flexibility, the smart contract will be updated to support operator delegation for cutting board management:

- **ValRewardAllocator Role**: A new `valRewardAllocator` role will be introduced that allows validators to delegate cutting board updates to a separate "hot key" while keeping their reward-receiving "cold key" (`operator`) secure and offline. This role can update cutting board configurations without having access to reward claims or other validator privileges
- **Operator Management**: The validator's cold key retains the ability to update or revoke the operator designation, providing ultimate control over delegation
- **Security Benefits**: This separation reduces the attack surface by allowing frequent cutting board updates through a hot key (`valRewardAllocator`) while protecting the main validator rewards and high-privilege operations with a cold key (`operator`)
- **ValRewardAllocator Compromise Recovery**: In the event that a `valRewardAllocator` key is compromised, the validator can immediately revoke the operator's permissions using their cold key (`operator`) and designate a new `valRewardAllocator`
- **Backward Compatibility**: Validators who prefer not to use operator delegation can continue to manage their cutting board directly with their primary key

### Forkchoice Attributes Extension

Building on the foundation established in [PR #26](https://github.com/berachain/bera-reth/pull/26), both the consensus layer (beacon-kit) and execution layer (Geth and Reth) require updates:

**Consensus Layer (beacon-kit) Updates:**

Based on the implementation in [PR #2836](https://github.com/berachain/beacon-kit/pull/2836), the consensus layer requires several specific modifications:

#### 1. PayloadAttributes Data Structure Extension
```go
type PayloadAttributes struct {
    // Existing fields...
    ParentProposerPubkey *crypto.BLSPubkey `json:"parentProposerPubKey"`
}
```
- **Field Type**: `*crypto.BLSPubkey` (48-byte BLS public key)
- **JSON Serialization**: Uses `"parentProposerPubKey"` tag for API compatibility
- **Nullable**: Pointer type allows nil values for pre-fork compatibility

#### 2. State Transition Integration
```go
func (st *StateTransition) ParentProposerPubkey(nextPayloadTimestamp uint64) (*crypto.BLSPubkey, error) {
    // Extract parent proposer pubkey from beacon state
    // Implementation details include:
    // - Retrieving parent block from state
    // - Extracting proposer index from parent block
    // - Converting proposer index to BLS public key
    // - Error handling for invalid or missing data
}
```

#### 3. Fork-Conditional Validation Logic
- **Pre-Electra1 Fork**: `ParentProposerPubkey` MUST be `nil`
- **Post-Electra1 Fork**: `ParentProposerPubkey` MUST be non-nil and valid
- **Validation Point**: Applied during payload request building and forkchoice updates
- **Error Handling**: Invalid pubkey states result in payload rejection

#### 4. Engine API Method Updates
- **New Methods**: `ForkchoiceUpdatedV3P11` and `NewPayloadV4P11`
- **Method Signatures**: Extended to handle `ParentProposerPubkey` parameter
- **Backward Compatibility**: Maintains existing method versions for pre-fork operation

#### 5. Forkchoice Update Process
- **Timing**: Parent proposer pubkey extracted during block finalization
- **Propagation**: Passed through `forkchoiceUpdated` calls to execution layer
- **Validation**: Execution layer validates pubkey presence and format post-fork
- **Failure Handling**: Missing or invalid pubkeys result in block rejection

**Execution Layer (Geth and Reth) Updates:**
1. **Require** the `ParentProposerPubkey` field in `BerachainPayloadAttributes` for all forkchoice updates after the hard fork activation
2. Extract the `ParentProposerPubkey` from `BerachainPayloadAttributes` in forkchoice updates  
3. Pass this pubkey to the enshrined `distributeFor` call during block execution
4. **Fork Validation**: Reject forkchoice updates that violate the fork-conditional pubkey requirements
5. **Data Type Handling**: Process the 48-byte BLS public key format consistently with consensus layer

**Note**: After the hard fork activation, forkchoice attributes that do not include the `ParentProposerPubkey` field or contain an invalid parent proposer pubkey will be rejected by the execution layer, treating such blocks as invalid to ensure consistent reward distribution.

### Execution Flow

1. **Block Start**: Execution layer receives forkchoice update with parent proposer pubkey
2. **Pubkey Validation**: Validate parent proposer pubkey format and presence (invalid blocks are rejected)
3. **Enshrined Distribution**: Call enshrined `distributeFor` at the very beginning of block execution to fulfill incentives for the previous block's proposer. The function is designed to never revert, but if an unexpected revert occurs, the protocol silently ignores it and continues processing
4. **Transaction Processing**: Process all user transactions, including any current proposer cutting board updates
5. **Real-Time Cutting Board Application**: Any cutting board updates made during transaction processing take effect immediately (no queue delay) and will be used for the next block's distribution

## Rationale

### Similar Ethereum Precedents

This approach follows established patterns in Ethereum and L2 ecosystems for enshrined system operations:
- **[EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) (processBeaconBlockRoot)**: Automatically stores beacon block roots for cryptographic verification
- **[EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) (processWithdrawalQueue)**: Handles validator withdrawals as part of block execution
- **OP-Stack Special Transactions**: The Optimism ecosystem uses special transaction types (0x7E deposit transactions, 0x7F system transactions) that enable direct sender specification, bypass signature validation, and allow contracts to see system addresses as `msg.sender` - providing a battle-tested precedent for enshrined operations with system-level execution

### Trust Model

The simplified approach eliminates the need for on-chain Merkle proof verification by trusting the consensus layer to provide accurate proposer information. This is justified because:

1. The consensus layer already validates block proposer identity
2. The execution layer inherently trusts consensus layer data for block construction
3. Malicious consensus clients cannot profit from providing incorrect proposer pubkeys
4. The change maintains the same security assumptions as other enshrined operations

### Performance Benefits

Enshrining eliminates:
- Gas costs for distribution transactions (estimated ~1,000,000 gas per distribution)
- Block space competition between distributions and user transactions
- Latency between block production and reward distribution
- **Cutting board queue delays**: Real-time cutting board execution eliminates any delays between strategy updates and their application, enabling immediate optimization of BGT rewards distribution

## Backward Compatibility

This change requires a hard fork to implement. The modification maintains backward compatibility by:

1. **Dual Interface**: Supporting both the new enshrined function and the existing proof-based function
2. **Existing Contracts**: All current reward allocation and distribution logic remains unchanged
3. **External Integration**: Third-party contracts and integrations continue to work without modification
4. **Shared Anti-Double-Claim Protection**: Both function variants will utilize the same timestamp-based history buffer system, ensuring no double-distribution can occur at the hard fork boundary or during the transition period

## Implementation Plan

### Phase 1: Contract Updates
- Modify `Distributor.sol` to support the new simplified enshrined interface alongside existing functionality
- Add `onlySystemCall` access controls for the new function variant
- **Implement real-time cutting board execution**: The current `BeraChef` contract queue validation prevents immediate cutting board updates. For example, immediate activation would require modifying the queue validation logic from `startBlock > block.number + rewardAllocationBlockDelay` to `startBlock >= block.number` to allow validators to set `startBlock = block.number` for immediate activation. **This enables effective same-block distribution since rewards are distributed at the top of the next block before any other transactions can execute.**
- **Implement cutting board operator separation**: Add operator delegation functionality to allow validators to designate separate hot keys (`valRewardAllocator`) for cutting board updates while maintaining cold key (`operator`) control over operator management and reward claims
- Deploy and test updated contracts with dual interface support, real-time cutting board functionality, and operator delegation

### Phase 2: Consensus and Execution Layer Integration
- **Beacon-kit Updates**: Modify beacon-kit to include parent proposer pubkey in `forkchoiceUpdated` calls
- **Execution Layer Updates**: Berachain Labs will implement enshrined `distributeFor` calls in both Geth and Reth forks
- Complete implementation of `BerachainEngineTypes` and custom payload handling
- Integrate automatic `distributeFor` calls into block execution process after transaction processing
- Add comprehensive testing for reward distribution timing and cross-layer integration

### Phase 3: Network Deployment
- Coordinate hard fork activation across network participants
- Monitor initial performance and adjust parameters if necessary
- Decommission external distribution bot infrastructure

### Phase 4: Migration (Critical for System Integrity)
- **Immediate Post-Fork**: Disable the external `distributeFor` function to prevent frontrunning of enshrined system calls
- **Frontrunning Risk**: External actors could potentially call the external function before the enshrined call executes, causing the enshrined call to fail due to timestamp already being processed
- **Long-term**: After enshrined system proves stable, consider removing the external function entirely to simplify the contract interface
- **Implementation**: Add a hard fork activation check (e.g., `block.timestamp >= PECTRA11_HARD_FORK_TIMESTAMP`) that disables external function calls after the fork

## Test Cases

1. **Normal Operation**: Verify automatic distribution occurs for each block with correct parent proposer pubkey
2. **Missing Pubkey**: Verify that forkchoice attributes without parent proposer pubkey result in invalid blocks after hard fork activation
3. **Invalid Pubkey**: Verify that malformed or invalid parent proposer public keys result in invalid blocks
4. **Backward Compatibility**: Ensure existing external `distributeFor` calls continue to work
5. **Gas Accounting**: Verify enshrined calls don't consume user transaction gas
6. **Double-Claim Prevention**: 
   - Verify that calling both enshrined and external `distributeFor` for the same block timestamp fails
   - Test that the shared history buffer prevents double-distribution during hard fork transition
   - Validate that processed timestamps are preserved across the upgrade
7. **Real-Time Cutting Board Updates**: Verify that cutting board updates within a block take effect immediately, enabling validators to optimize their strategy with full chain state visibility
8. **Cutting Board Queue Elimination**: Test that cutting board changes take effect immediately without any queue-based delays
9. **Strategy Optimization with Omniscient View**: Validate that validators can update their cutting board strategy with complete chain state visibility for future reward optimization
10. **Hard Fork Boundary**: Test distribution behavior immediately before, during, and after hard fork activation
11. **Frontrunning Prevention**: Verify that external `distributeFor` function is properly disabled after hard fork activation
12. **Event Emission**: Determine whether enshrined `distributeFor` calls can emit events and ensure consistent behavior with external calls
13. **Block Validity**: Confirm that missing or invalid parent proposer pubkeys result in block rejection
14. **Operator Delegation**: Test that designated operators can update cutting board configurations but cannot access reward claims or other validator privileges
15. **Operator Revocation**: Verify that validators can revoke operator permissions and that revoked operators can no longer update cutting boards
16. **Operator Key Compromise**: Test security recovery scenario where an operator key is compromised and needs to be replaced
17. **Operator Authorization**: Ensure unauthorized addresses cannot act as operators and that only properly designated operators can update cutting boards

## Security Considerations

### Hard Fork Transition Security
- **Double-Claim Prevention**: The external `distributeFor` function will be disabled after hard fork activation to prevent any overlap with the enshrined distribution mechanism
- **Buffer State Preservation**: The processed timestamps buffer for the external function must be preserved across the hard fork upgrade to maintain continuity for any remaining external calls before complete migration
- **Transition Monitoring**: Implement comprehensive logging to track both enshrined and external distributions during the transition period

### Execution Layer Trust
- The consensus layer must be trusted to provide accurate parent proposer pubkeys
- This matches existing trust assumptions for other enshrined operations
- Risk mitigation through extensive testing and gradual rollout

### Access Control
- Only the system address (`0xffffFFFfFFffffffffffffffFfFFFfffFFFfFFfE`) should be able to call the simplified `distributeFor` function
- Prevent unauthorized calls that could manipulate reward distribution
- Maintain audit trails for distribution activities
- Preserve existing access controls for the proof-based function variant

### Operator Delegation Security
- **Key Separation Benefits**: Operator delegation reduces risk by separating frequently-used cutting board update keys from high-value reward-claiming keys
- **Compromise Mitigation**: If an operator key is compromised, validators can immediately revoke permissions without affecting their main validator operations or reward access
- **Operator Scope Limitation**: Operators should only have permission to update cutting board configurations and not access reward claims or other sensitive validator functions
- **Cold Key Control**: The validator's cold key must retain ultimate authority over operator designation, revocation, and reward management
- **Audit Trail**: All operator actions should be logged and traceable for security monitoring and accountability

### Economic Impact
- Monitor reward distribution patterns for any unexpected behavior
- Ensure gas savings don't create unintended economic incentives
- Validate that real-time distribution doesn't affect validator behavior
- **Strategy Optimization Timing**: Monitor for potential MEV or gaming opportunities created by validators having complete chain state visibility when updating cutting board strategies
- **Reward Distribution Fairness**: Ensure that rewarding previous proposers while allowing current proposers complete chain state visibility doesn't create unfair advantages or market manipulation opportunities

### Block Validity and Denial of Service
- Missing or invalid parent proposer pubkeys will result in block rejection, ensuring network consistency
- Ensure enshrined calls cannot be used to attack block execution
- Implement proper error handling within the enshrined call (failures should not prevent block production after pubkey validation)
- Consider gas limits and execution time bounds for the enshrined distribution logic

### Non-Reverting Design Security
- **Expected Behavior**: The enshrined `distributeFor` function is designed to never revert based on smart contract implementation
- **Unexpected Revert Handling**: If unexpected reverts occur due to contract bugs, they are silently ignored to prevent consensus disruption
- **Contract Issue Indication**: Reverts indicate smart contract problems that require fixes rather than normal operation failures

## Reference Implementation

- **[Distributor.sol](https://github.com/berachain/contracts/blob/main/src/pol/rewards/Distributor.sol)**: Current implementation of reward distribution logic
- **Ethereum EIPs**: [EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) and [EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) as models for enshrined system operations

## Future Work

### Default Cutting Board Strategy

Future versions of Reth will include a **simple default cutting board strategy** that automatically manages BGT distribution for validators. This strategy will:

1. **Simple Implementation**: Provide a basic, efficient default strategy without complex configuration options
2. **Pre-Distribution Optimization**: Update the cutting board configuration before the enshrined `distributeFor` call
3. **Seamless Integration**: Work transparently with the enshrined distribution mechanism without requiring any hard fork - strategies can be deployed and updated through normal execution layer upgrades

### Validator Benefits

Validators will be able to leverage this system to:

- **Set-and-Forget Operation**: Use the default strategy without any configuration required
- **Custom Strategies**: Sophisticated validators can write and deploy their own custom strategy implementations
- **Enhanced Yields**: Benefit from algorithmic optimization that may outperform manual cutting board management
- **Flexible Architecture**: The system will be designed to support pluggable strategy implementations

This future enhancement will make Proof of Liquidity rewards more accessible to validators while maintaining the flexibility for advanced users to implement fully custom distribution strategies.

## Copyright

All copyrights and related rights in this work are waived under CCO 1.0 Universal.