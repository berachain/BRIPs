---
mip: 0004
title: Enshrined Proof of Liquidity Reward Distribution
author: rezbera, calbera
status: Draft
created: 2025-06-19
type: Core
requires: BRIP-0001
---

## Summary

This BRIP proposes enshrining the `distributeFor` function call into the execution layer, enabling automatic incentive fulfillment at the end of each block without relying on external transactions or bots. This change eliminates gas costs and timing dependencies for Proof of Liquidity reward distribution, enabling real-time reward processing and improved network economics. **A key requirement of this proposal is reducing the cutting board queue to real-time execution**, allowing validators to update their BGT rewards distribution strategy and immediately fulfill incentives with the new configuration in the same block.

## Motivation

Berachain's Proof of Liquidity consensus mechanism requires regular incentive fulfillment for validators based on their liquidity provision. In exchange for these incentives, validators direct BGT rewards to vaults through their cutting board configuration. The `distributeFor` function performs this incentive fulfillment. Currently, this process relies on external actors calling the `distributeFor` function, which presents several limitations:

1. **Gas Dependency**: Distribution transactions compete with user transactions for block space and are subject to gas price fluctuations
2. **Timing Uncertainty**: No guarantee that reward distribution occurs promptly after each block
3. **Bot Infrastructure**: Requires maintaining external infrastructure to monitor and trigger distributions
4. **Economic Inefficiency**: Gas costs for distribution reduce overall network economic efficiency
5. **Cutting Board Queue Latency**: The current cutting board system introduces delays between strategy updates and their application, preventing validators from updating their BGT rewards distribution strategy and having `distributeFor` fulfill incentives with the updated configuration in the same block

By enshrining `distributeFor` calls at the execution layer, we can guarantee that `distributeFor` performs incentive fulfillment deterministically for every block without external dependencies. **This proposal requires implementing real-time cutting board execution**, eliminating any queue delays and enabling validators to update their BGT rewards distribution strategy (cutting board) within the same block that earns the incentives, with the new strategy taking effect immediately when `distributeFor` executes. **This accelerates the Proof of Liquidity flywheel by enabling immediate optimization of BGT distribution**, allowing validators to respond instantly to market conditions and liquidity provision opportunities.

## Specification

### Execution Layer Integration

Berachain Labs will implement automatic `distributeFor` function calls at the end of each block processing in both Geth and Reth forked execution clients, after all regular transaction execution. This requires modifications to the block execution process in the forked clients.

### Contract Modifications

The `Distributor.sol` contract will require updates to support a new enshrined interface alongside the existing implementation:

#### New Enshrined Function Signature

A new simplified `distributeFor` function variant will be added that leverages proposer information available from forkchoice attributes:

```solidity
function distributeFor(
    uint64 nextTimestamp,
    bytes calldata proposerPubkey
) external onlySystemCall nonReentrant {
    // Simplified implementation - trust consensus layer data
    _processTimestampInBuffer(nextTimestamp);
    _executeDistribution(nextTimestamp, proposerPubkey);
}
```

#### Key Changes from Current Implementation

- **Removed proposer index and Merkle proofs**: The proposer pubkey will be provided directly from forkchoice attributes, eliminating the need for cryptographic proof verification
- **Proposer pubkey source**: The 48-byte BLS public key will be passed from the consensus layer via the `BerachainPayloadAttributes.proposer_pubkey` field
- **Simplified verification**: Trust the consensus layer data rather than requiring on-chain proof verification
- **Access control**: Only the system address (`0xfffffffffffffffffffffffffffffffffffffffe`) can call this simplified version

#### Contract Interface Updates

1. Add the new simplified function variant for enshrined calls using function overloading
2. Maintain the existing proof-based function for backward compatibility during transition period
3. Implement `onlySystemCall` modifier to restrict access to the system address (`0xfffffffffffffffffffffffffffffffffffffffe`)
4. Share common reward distribution logic through internal `_executeDistribution()` function
5. **Preserve existing anti-double-claim mechanisms**: Both function variants will share the same timestamp-based history buffer via `_processTimestampInBuffer()`
6. **Event Emission**: The enshrined function should emit the same events as the external function for consistency and observability (to be verified during implementation whether enshrined calls can emit events)
7. **Migration Path**: The external function should be disabled after hard fork activation to prevent frontrunning of the enshrined system call, and potentially removed entirely once the enshrined system proves stable

#### Cutting Board Real-Time Execution

To enable same-block cutting board updates and immediate incentive fulfillment, the `BeraChef` contract requires modifications to eliminate queue delays:

- **Queue Validation Updates**: Modify the queue validation logic to allow same-block activation by changing the validation from `startBlock <= block.number + rewardAllocationBlockDelay` to `startBlock <= block.number`
- **Same-Block Strategy Changes**: This enables validators to update their cutting board configuration and have the enshrined `distributeFor` use the new allocation weights in the same block

### Forkchoice Attributes Extension

Building on the foundation established in [PR #26](https://github.com/berachain/bera-reth/pull/26), both the consensus layer (beacon-kit) and execution layer (Geth and Reth) require updates:

**Consensus Layer (beacon-kit) Updates:**
1. Modify beacon-kit to include the block proposer's public key in `forkchoiceUpdated` calls
2. Extract the proposer pubkey from the beacon block and pass it via `BerachainPayloadAttributes.proposer_pubkey`
3. Ensure all `forkchoiceUpdated` calls after hard fork activation include the proposer pubkey

**Execution Layer (Geth and Reth) Updates:**
1. **Require** the `proposer_pubkey` field in `BerachainPayloadAttributes` for all forkchoice updates after the hard fork activation
2. Extract the `proposer_pubkey` from `BerachainPayloadAttributes` in forkchoice updates
3. Pass this pubkey to the enshrined `distributeFor` call during block execution
4. Use the block timestamp as the `nextTimestamp` parameter

**Note**: After the hard fork activation, forkchoice attributes that do not include the `proposer_pubkey` field or contain an invalid proposer pubkey will be rejected by the execution layer, treating such blocks as invalid to ensure consistent reward distribution.

### Execution Flow

1. **Block Start**: Execution layer receives forkchoice update with proposer pubkey
2. **Pubkey Validation**: Validate proposer pubkey format and presence (invalid blocks are rejected)
3. **Transaction Processing**: Process all user transactions, including any proposer cutting board updates
4. **Real-Time Cutting Board Application**: Any cutting board updates made during transaction processing take effect immediately (no queue delay)
5. **Post-Transaction Processing**: After all transactions are processed, call enshrined `distributeFor`
6. **Incentive Fulfillment**: Call enshrined `distributeFor` to fulfill incentives for the proposing validator using the latest cutting board configuration from step 4

## Rationale

### Similar Ethereum Precedents

This approach follows established patterns in Ethereum and L2 ecosystems for enshrined system operations:
- **[EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) (processBeaconBlockRoot)**: Automatically stores beacon block roots for cryptographic verification
- **[EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) (processWithdrawalQueue)**: Handles validator withdrawals as part of block execution
- **OP-Stack Special Transactions**: The Optimism ecosystem uses special transaction types (0x7E deposit transactions, 0x7F system transactions) that enable direct sender specification, bypass signature validation, and allow contracts to see system addresses as `msg.sender` - providing a battle-tested precedent for enshrined operations with system-level execution

### Trust Model

The simplified approach eliminates the need for on-chain Merkle proof verification by trusting the consensus layer to provide accurate proposer information. This is justified because:

1. The consensus layer already validates block proposer identity
2. The execution layer inherently trusts consensus layer data for block construction
3. Malicious consensus clients cannot profit from providing incorrect proposer pubkeys
4. The change maintains the same security assumptions as other enshrined operations

### Performance Benefits

Enshrining eliminates:
- Gas costs for distribution transactions (estimated ~1,000,000 gas per distribution)
- Block space competition between distributions and user transactions
- Latency between block production and reward distribution
- **Cutting board queue delays**: Real-time cutting board execution eliminates any delays between strategy updates and their application, enabling immediate optimization of BGT rewards distribution

## Backward Compatibility

This change requires a hard fork to implement. The modification maintains backward compatibility by:

1. **Dual Interface**: Supporting both the new enshrined function and the existing proof-based function
2. **Existing Contracts**: All current reward allocation and distribution logic remains unchanged
3. **External Integration**: Third-party contracts and integrations continue to work without modification
4. **Shared Anti-Double-Claim Protection**: Both function variants will utilize the same timestamp-based history buffer system, ensuring no double-distribution can occur at the hard fork boundary or during the transition period

## Implementation Plan

### Phase 1: Contract Updates
- Modify `Distributor.sol` to support the new simplified enshrined interface alongside existing functionality
- Add `onlySystemCall` access controls for the new function variant
- **Implement real-time cutting board execution**: The current `BeraChef` contract queue validation prevents same-block cutting board updates. For example, same-block activation would require modifying the queue validation logic from `startBlock <= block.number + rewardAllocationBlockDelay` to `startBlock <= block.number` to allow validators to set `startBlock = block.number` for immediate activation
- Deploy and test updated contracts with dual interface support and real-time cutting board functionality

### Phase 2: Consensus and Execution Layer Integration
- **Beacon-kit Updates**: Modify beacon-kit to include proposer pubkey in `forkchoiceUpdated` calls
- **Execution Layer Updates**: Berachain Labs will implement enshrined `distributeFor` calls in both Geth and Reth forks
- Complete implementation of `BerachainEngineTypes` and custom payload handling
- Integrate automatic `distributeFor` calls into block execution process after transaction processing
- Add comprehensive testing for reward distribution timing and cross-layer integration

### Phase 3: Network Deployment
- Coordinate hard fork activation across network participants
- Monitor initial performance and adjust parameters if necessary
- Decommission external distribution bot infrastructure

### Phase 4: Migration (Critical for System Integrity)
- **Immediate Post-Fork**: Disable the external `distributeFor` function to prevent frontrunning of enshrined system calls
- **Frontrunning Risk**: External actors could potentially call the external function before the enshrined call executes, causing the enshrined call to fail due to timestamp already being processed
- **Long-term**: After enshrined system proves stable, consider removing the external function entirely to simplify the contract interface
- **Implementation**: Add a hard fork activation check (e.g., `block.timestamp >= HARD_FORK_TIMESTAMP`) that disables external function calls after the fork

## Test Cases

1. **Normal Operation**: Verify automatic distribution occurs for each block with correct proposer pubkey
2. **Missing Pubkey**: Verify that forkchoice attributes without proposer pubkey result in invalid blocks after hard fork activation
3. **Invalid Pubkey**: Verify that malformed or invalid proposer public keys result in invalid blocks
4. **Backward Compatibility**: Ensure existing external `distributeFor` calls continue to work
5. **Gas Accounting**: Verify enshrined calls don't consume user transaction gas
6. **Double-Claim Prevention**: 
   - Verify that calling both enshrined and external `distributeFor` for the same timestamp fails
   - Test that the shared history buffer prevents double-distribution during hard fork transition
   - Validate that processed timestamps are preserved across the upgrade
7. **Real-Time Cutting Board Updates**: Verify that cutting board updates within a block immediately affect `distributeFor` incentive fulfillment in the same block
8. **Cutting Board Queue Elimination**: Test that cutting board changes take effect immediately without any queue-based delays
9. **Same-Block Strategy Optimization**: Validate that validators can update their cutting board strategy and have `distributeFor` fulfill optimized incentives in the same block
10. **Hard Fork Boundary**: Test distribution behavior immediately before, during, and after hard fork activation
11. **Frontrunning Prevention**: Verify that external `distributeFor` function is properly disabled after hard fork activation
12. **Event Emission**: Determine whether enshrined `distributeFor` calls can emit events and ensure consistent behavior with external calls
13. **Block Validity**: Confirm that missing or invalid proposer pubkeys result in block rejection

## Security Considerations

### Hard Fork Transition Security
- **Double-Claim Prevention**: Both enshrined and external `distributeFor` functions will share the same timestamp-based history buffer system (`_processedTimestampsBuffer`) to prevent double-distribution during the transition
- **Buffer State Preservation**: The processed timestamps buffer must be preserved across the hard fork upgrade to maintain continuity of anti-double-claim protection
- **Transition Monitoring**: Implement comprehensive logging to track both enshrined and external distributions during the transition period

### Execution Layer Trust
- The consensus layer must be trusted to provide accurate proposer pubkeys
- This matches existing trust assumptions for other enshrined operations
- Risk mitigation through extensive testing and gradual rollout

### Access Control
- Only the system address (`0xfffffffffffffffffffffffffffffffffffffffe`) should be able to call the simplified `distributeFor` function
- Prevent unauthorized calls that could manipulate reward distribution
- Maintain audit trails for distribution activities
- Preserve existing access controls for the proof-based function variant

### Economic Impact
- Monitor reward distribution patterns for any unexpected behavior
- Ensure gas savings don't create unintended economic incentives
- Validate that real-time distribution doesn't affect validator behavior
- **Real-Time Cutting Board Risks**: Monitor for potential MEV or gaming opportunities created by same-block cutting board updates and reward distribution
- **Strategy Optimization Timing**: Ensure that immediate cutting board application doesn't create unfair advantages or market manipulation opportunities

### Block Validity and Denial of Service
- Missing or invalid proposer pubkeys will result in block rejection, ensuring network consistency
- Ensure enshrined calls cannot be used to attack block execution
- Implement proper error handling within the enshrined call (failures should not prevent block production after pubkey validation)
- Consider gas limits and execution time bounds for the enshrined distribution logic

## Reference Implementation

The reference implementation builds upon:
- **[PR #26](https://github.com/berachain/bera-reth/pull/26)**: Foundation for `BerachainPayloadAttributes` with proposer pubkey support (execution layer)
- **[Distributor.sol](https://github.com/berachain/contracts/blob/main/src/pol/rewards/Distributor.sol)**: Current implementation of reward distribution logic
- **Ethereum EIPs**: [EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) and [EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) as models for enshrined system operations

## Future Work

### Default Cutting Board Strategy

Future versions of Reth will include a **simple default cutting board strategy** that automatically manages BGT distribution for validators. This strategy will:

1. **Simple Implementation**: Provide a basic, efficient default strategy without complex configuration options
2. **Pre-Distribution Optimization**: Update the cutting board configuration before the enshrined `distributeFor` call
3. **Seamless Integration**: Work transparently with the enshrined distribution mechanism without requiring any hard fork - strategies can be deployed and updated through normal execution layer upgrades

### Validator Benefits

Validators will be able to leverage this system to:

- **Set-and-Forget Operation**: Use the default strategy without any configuration required
- **Custom Strategies**: Sophisticated validators can write and deploy their own custom strategy implementations
- **Enhanced Yields**: Benefit from algorithmic optimization that may outperform manual cutting board management
- **Flexible Architecture**: The system will be designed to support pluggable strategy implementations

This future enhancement will make Proof of Liquidity rewards more accessible to validators while maintaining the flexibility for advanced users to implement fully custom distribution strategies.

## Copyright

All copyrights and related rights in this work are waived under CCO 1.0 Universal.