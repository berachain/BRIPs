---
mip: 0004
title: Enshrined Proof of Liquidity Reward Distribution
author: rezbera, calbera
status: Draft
created: 2025-06-19
type: Core
requires: BRIP-0001
---

## Summary

This BRIP proposes enshrining the `distributeFor` function call into the execution layer, enabling automatic validator reward distribution at the end of each block without relying on external transactions or bots. This change eliminates gas costs and timing dependencies for Proof of Liquidity reward distribution, enabling real-time reward processing and improved network economics.

## Motivation

Berachain's Proof of Liquidity consensus mechanism requires regular distribution of block rewards to validators based on their liquidity provision. Currently, this distribution relies on external actors calling the `distributeFor` function, which presents several limitations:

1. **Gas Dependency**: Distribution transactions compete with user transactions for block space and are subject to gas price fluctuations
2. **Timing Uncertainty**: No guarantee that reward distribution occurs promptly after each block
3. **Bot Infrastructure**: Requires maintaining external infrastructure to monitor and trigger distributions
4. **Economic Inefficiency**: Gas costs for distribution reduce overall network economic efficiency
5. **Cutting Board Update Limitations**: Validators cannot easily update their BGT distribution strategy and receive rewards with the updated configuration in the same block

By enshrining `distributeFor` calls at the execution layer, similar to how `processBeaconBlockRoot` and `processWithdrawalQueue` are handled, we can guarantee that reward distribution occurs deterministically for every block without external dependencies. Critically, by executing the distribution at the end of each block, validators can update their BGT distribution strategy (cutting board) within the same block that earns the rewards.

## Specification

### Execution Layer Integration

Berachain Labs will implement automatic `distributeFor` function calls at the end of each block processing in both Geth and Reth forked execution clients, after all regular transaction execution. This requires modifications to the block execution process in the forked clients.

### Contract Modifications

The `Distributor.sol` contract will require updates to support a new enshrined interface alongside the existing implementation:

#### New Enshrined Function Signature

A new simplified `distributeFor` function variant will be added that leverages proposer information available from forkchoice attributes:

```solidity
function distributeFor(
    uint64 nextTimestamp,
    bytes calldata proposerPubkey
) external onlySystemCall nonReentrant {
    // Simplified implementation - trust consensus layer data
    _processTimestampInBuffer(nextTimestamp);
    _executeDistribution(nextTimestamp, proposerPubkey);
}
```

#### Key Changes from Current Implementation

- **Removed proposer index and Merkle proofs**: The proposer pubkey will be provided directly from forkchoice attributes, eliminating the need for cryptographic proof verification
- **Proposer pubkey source**: The 48-byte BLS public key will be passed from the consensus layer via the `BerachainPayloadAttributes.proposer_pubkey` field
- **Simplified verification**: Trust the consensus layer data rather than requiring on-chain proof verification
- **Access control**: Only the system address (`0xfffffffffffffffffffffffffffffffffffffffe`) can call this simplified version

#### Contract Interface Updates

1. Add the new simplified function variant for enshrined calls using function overloading
2. Maintain the existing proof-based function for backward compatibility during transition period
3. Implement `onlySystemCall` modifier to restrict access to the system address (`0xfffffffffffffffffffffffffffffffffffffffe`)
4. Share common reward distribution logic through internal `_executeDistribution()` function
5. **Preserve existing anti-double-claim mechanisms**: Both function variants will share the same timestamp-based history buffer via `_processTimestampInBuffer()`
6. **Event Emission**: The enshrined function should emit the same events as the external function for consistency and observability (to be verified during implementation whether enshrined calls can emit events)
7. **Migration Path**: The external function should be disabled after hard fork activation to prevent frontrunning of the enshrined system call, and potentially removed entirely once the enshrined system proves stable

### Forkchoice Attributes Extension

Building on the foundation established in [PR #26](https://github.com/berachain/bera-reth/pull/26), the Geth and Reth execution layer implementations will:

1. **Require** the `proposer_pubkey` field in `BerachainPayloadAttributes` for all forkchoice updates after the hard fork activation
2. Extract the `proposer_pubkey` from `BerachainPayloadAttributes` in forkchoice updates
3. Pass this pubkey to the enshrined `distributeFor` call during block execution
4. Use the block timestamp as the `nextTimestamp` parameter

**Note**: After the hard fork activation, forkchoice attributes that do not include the `proposer_pubkey` field or contain an invalid proposer pubkey will be rejected by the execution layer, treating such blocks as invalid to ensure consistent reward distribution.

### Execution Flow

1. **Block Start**: Execution layer receives forkchoice update with proposer pubkey
2. **Pubkey Validation**: Validate proposer pubkey format and presence (invalid blocks are rejected)
3. **Transaction Processing**: Process all user transactions, including any proposer cutting board updates
4. **Post-Transaction Processing**: After all transactions are processed, call enshrined `distributeFor`
5. **Reward Distribution**: Process rewards for the proposing validator using the latest cutting board configuration

## Rationale

### Similar Ethereum Precedents

This approach follows established patterns in Ethereum for enshrined system operations:
- **[EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) (processBeaconBlockRoot)**: Automatically stores beacon block roots for cryptographic verification
- **[EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) (processWithdrawalQueue)**: Handles validator withdrawals as part of block execution

### Trust Model

The simplified approach eliminates the need for on-chain Merkle proof verification by trusting the consensus layer to provide accurate proposer information. This is justified because:

1. The consensus layer already validates block proposer identity
2. The execution layer inherently trusts consensus layer data for block construction
3. Malicious consensus clients cannot profit from providing incorrect proposer pubkeys
4. The change maintains the same security assumptions as other enshrined operations

### Performance Benefits

Enshrining eliminates:
- Gas costs for distribution transactions (estimated ~1,000,000 gas per distribution)
- Block space competition between distributions and user transactions
- Latency between block production and reward distribution

## Backward Compatibility

This change requires a hard fork to implement. The modification maintains backward compatibility by:

1. **Dual Interface**: Supporting both the new enshrined function and the existing proof-based function
2. **Existing Contracts**: All current reward allocation and distribution logic remains unchanged
3. **External Integration**: Third-party contracts and integrations continue to work without modification
4. **Shared Anti-Double-Claim Protection**: Both function variants will utilize the same timestamp-based history buffer system, ensuring no double-distribution can occur at the hard fork boundary or during the transition period

## Implementation Plan

### Phase 1: Contract Updates
- Modify `Distributor.sol` to support the new simplified enshrined interface alongside existing functionality
- Add `onlySystemCall` access controls for the new function variant
- Deploy and test updated contracts with dual interface support

### Phase 2: Execution Layer Integration
- Berachain Labs will implement enshrined `distributeFor` calls in both Geth and Reth forks
- Complete implementation of `BerachainEngineTypes` and custom payload handling
- Integrate automatic `distributeFor` calls into block execution process after transaction processing
- Add comprehensive testing for reward distribution timing and execution layer integration

### Phase 3: Network Deployment
- Coordinate hard fork activation across network participants
- Monitor initial performance and adjust parameters if necessary
- Decommission external distribution bot infrastructure

### Phase 4: Migration (Critical for System Integrity)
- **Immediate Post-Fork**: Disable the external `distributeFor` function to prevent frontrunning of enshrined system calls
- **Frontrunning Risk**: External actors could potentially call the external function before the enshrined call executes, causing the enshrined call to fail due to timestamp already being processed
- **Long-term**: After enshrined system proves stable, consider removing the external function entirely to simplify the contract interface
- **Implementation**: Add a hard fork activation check (e.g., `block.timestamp >= HARD_FORK_TIMESTAMP`) that disables external function calls after the fork

## Test Cases

1. **Normal Operation**: Verify automatic distribution occurs for each block with correct proposer pubkey
2. **Missing Pubkey**: Verify that forkchoice attributes without proposer pubkey result in invalid blocks after hard fork activation
3. **Invalid Pubkey**: Verify that malformed or invalid proposer public keys result in invalid blocks
4. **Backward Compatibility**: Ensure existing external `distributeFor` calls continue to work
5. **Gas Accounting**: Verify enshrined calls don't consume user transaction gas
6. **Double-Claim Prevention**: 
   - Verify that calling both enshrined and external `distributeFor` for the same timestamp fails
   - Test that the shared history buffer prevents double-distribution during hard fork transition
   - Validate that processed timestamps are preserved across the upgrade
7. **Hard Fork Boundary**: Test distribution behavior immediately before, during, and after hard fork activation
8. **Frontrunning Prevention**: Verify that external `distributeFor` function is properly disabled after hard fork activation
9. **Event Emission**: Determine whether enshrined `distributeFor` calls can emit events and ensure consistent behavior with external calls
10. **Block Validity**: Confirm that missing or invalid proposer pubkeys result in block rejection

## Security Considerations

### Hard Fork Transition Security
- **Double-Claim Prevention**: Both enshrined and external `distributeFor` functions will share the same timestamp-based history buffer system (`_processedTimestampsBuffer`) to prevent double-distribution during the transition
- **Buffer State Preservation**: The processed timestamps buffer must be preserved across the hard fork upgrade to maintain continuity of anti-double-claim protection
- **Transition Monitoring**: Implement comprehensive logging to track both enshrined and external distributions during the transition period

### Execution Layer Trust
- The consensus layer must be trusted to provide accurate proposer pubkeys
- This matches existing trust assumptions for other enshrined operations
- Risk mitigation through extensive testing and gradual rollout

### Access Control
- Only the system address (`0xfffffffffffffffffffffffffffffffffffffffe`) should be able to call the simplified `distributeFor` function
- Prevent unauthorized calls that could manipulate reward distribution
- Maintain audit trails for distribution activities
- Preserve existing access controls for the proof-based function variant

### Economic Impact
- Monitor reward distribution patterns for any unexpected behavior
- Ensure gas savings don't create unintended economic incentives
- Validate that real-time distribution doesn't affect validator behavior

### Block Validity and Denial of Service
- Missing or invalid proposer pubkeys will result in block rejection, ensuring network consistency
- Ensure enshrined calls cannot be used to attack block execution
- Implement proper error handling within the enshrined call (failures should not prevent block production after pubkey validation)
- Consider gas limits and execution time bounds for the enshrined distribution logic

## Reference Implementation

The reference implementation builds upon:
- **[PR #26](https://github.com/berachain/bera-reth/pull/26)**: Foundation for `BerachainPayloadAttributes` with proposer pubkey support
- **[Distributor.sol](https://github.com/berachain/contracts/blob/main/src/pol/rewards/Distributor.sol)**: Current implementation of reward distribution logic
- **Ethereum EIPs**: [EIP-4788](https://eips.ethereum.org/EIPS/eip-4788) and [EIP-4895](https://eips.ethereum.org/EIPS/eip-4895) as models for enshrined system operations

## Future Work

### External Function Deprecation

The external proof-based function must be disabled immediately after hard fork activation to prevent frontrunning attacks, and could be removed entirely once the enshrined system proves stable.

**Critical Security Requirement**:
- **Frontrunning Prevention**: External actors could frontrun the enshrined system call by calling the external `distributeFor` function first, causing the enshrined call to fail with `TimestampAlreadyProcessed`
- **System Integrity**: This would break the guaranteed execution property of the enshrined system and could lead to missed reward distributions

**Benefits of Deprecation**:
- **Simplify Contract Interface**: Remove the complex proof-verification logic and dual function variants
- **Eliminate External Dependencies**: No longer require external actors to call `distributeFor`
- **Reduce Attack Surface**: Remove the external entry point that requires Merkle proof validation
- **Prevent Frontrunning**: Ensure enshrined calls always execute successfully
- **Streamline Maintenance**: Focus development efforts on the enshrined system only

**Implementation Approach**:
```solidity
modifier notAfterFork() {
    require(block.timestamp < HARD_FORK_TIMESTAMP, "External distributeFor disabled after fork");
    _;
}

function distributeFor(
    uint64 nextTimestamp,
    uint64 proposerIndex,
    bytes calldata pubkey,
    bytes32[] calldata proposerIndexProof,
    bytes32[] calldata pubkeyProof
) external notAfterFork {
    // Existing implementation
}
```

### Default Cutting Board Strategy

Future versions of Reth will include a **default cutting board strategy** that automatically optimizes BGT distribution for validators. This strategy will:

1. **Automatic Updates**: Periodically analyze validator performance and liquidity provision metrics
2. **Pre-Distribution Optimization**: Update the cutting board configuration before the enshrined `distributeFor` call
3. **Customizable Parameters**: Allow validators to configure optimization goals (e.g., maximize rewards, diversify risk, support specific protocols)
4. **Seamless Integration**: Work transparently with the enshrined distribution mechanism

### Validator Benefits

Validators will be able to leverage this system to:

- **Set-and-Forget Operation**: Configure high-level preferences and let the system optimize distribution automatically
- **Real-Time Responsiveness**: Automatically adjust to changing market conditions and protocol performance
- **Enhanced Yields**: Benefit from algorithmic optimization that may outperform manual cutting board management
- **Custom Strategies**: Override the default strategy with custom logic for sophisticated use cases

This future enhancement will make Proof of Liquidity rewards more accessible to validators while maintaining the flexibility for advanced users to implement custom distribution strategies.

## Copyright

All copyrights and related rights in this work are waived under CCO 1.0 Universal.